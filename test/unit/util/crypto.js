const should = require('should');
const crypto = require('../../../lib/util/crypto');

describe('util/crypto', () => {
  describe('hashPassword/verifyPassword @slow', () => {
    const { hashPassword, verifyPassword } = crypto;
    // we do not actually verify the hashing itself, as:
    // 1. it is entirely performed by bcrypt, which has is own tests.
    // 2. bcrypt is intentionally slow, and we would like unit tests to be fast.

    it('should always return a Promise', () => {
      hashPassword('').should.be.a.Promise();
      hashPassword('password').should.be.a.Promise();
      verifyPassword('password', 'hashhash').should.be.a.Promise();
    });

    it('should return a Promise of null given a blank plaintext', (done) => {
      hashPassword('').then((result) => {
        should(result).equal(null);
        done();
      });
    });

    it('should not attempt to verify empty plaintext', (done) => {
      verifyPassword('', '$2a$12$hCRUXz/7Hx2iKPLCduvrWugC5Q/j5e3bX9KvaYvaIvg/uvFYEpzSy').then((result) => {
        result.should.equal(false);
        done();
      });
    });

    it('should not attempt to verify empty hash', (done) => {
      verifyPassword('password', '').then((result) => {
        result.should.equal(false);
        done();
      });
    });
  });

  describe('generateToken', () => {
    const { generateToken } = crypto;
    it('should return 48-byte tokens by default', () => {
      generateToken().should.be.a.token();
    });

    it('should accept other lengths', () => {
      // the numbers are not equal due to the base64 conversion.
      generateToken(12).length.should.equal(16);
    });
  });

  describe('generateKeypair', () => {
    const { generateKeypair } = crypto;
    it('should return reasonable values in a Promise @slow', (done) => {
      generateKeypair('test').then((result) => {
        result.pubkey.should.be.a.base64string();
        result.privkey.should.be.a.base64string();
        result.salt.should.be.a.base64string();
        result.iv.should.be.a.base64string();
        done();
      });
    });
  });

  describe('generateLocalCipherer', () => {
    const { generateKeypair, generateLocalCipherer } = crypto;
    it('should return an encipherer with a local key @slow', (done) => {
      generateKeypair('test').then((keys) => {
        const [ localkey, cipherer ] = generateLocalCipherer(keys);
        localkey.should.be.a.base64string();
        cipherer.should.be.a.Function();
        done();
      });
    });

    it('should return an (iv, cipher) tuple when the cipherer is given an iv @slow', (done) => {
      generateKeypair('test').then((keys) => {
        const [ , cipherer ] = generateLocalCipherer(keys);
        const [ iv, cipher ] = cipherer();
        iv.should.be.a.base64string();
        cipher.update.should.be.a.Function();
        cipher.final.should.be.a.Function();
        done();
      });
    });
  });

  describe('getLocalDecipherer', () => {
    const { generateKeypair, generateLocalCipherer, getLocalDecipherer } = crypto;
    it('should successfully round-trip a piece of data @slow', (done) => {
      // init.
      generateKeypair('topsecret').then((initkeys) => {
        // create local cipher; encrypt our plaintext.
        const [ localkey, cipherer ] = generateLocalCipherer(initkeys);
        const [ localiv, cipher ] = cipherer();

        const plain = 'a way a lone a last a loved a long the riverrun,';
        const encrypted = cipher.update(plain, 'utf8', 'base64') + cipher.final('base64');

        // now get a local decipher and decrypt. verify round-trip.
        const keys = { privkey: initkeys.privkey, salt: initkeys.salt, iv: initkeys.iv, local: { key: localkey } };
        getLocalDecipherer(keys, 'topsecret').then((decipherer) => {
          const decipher = decipherer(localiv);
          const unencrypted = decipher.update(encrypted, 'base64', 'utf8') + decipher.final('utf8');

          unencrypted.should.equal(plain);
          done();
        });
      });
    });
  });

  describe('ursa backwards compatibility', () => {
    const { getLocalDecipherer } = crypto;

    // this encrypted data generated by Central code circa v0.5:
    const keys = {
      privkey: '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',
      salt: 'F0TLadQjPnPGOfUQ2kZM+g==',
      iv: 'hXs4HQKvDyP+kOlf9Y1ByA==',
      local: { key: 'bcFeKDF3Sg8W91Uf5uxaIlM2uK0cUN9tBSGoASbC4LeIPqx65+6zmjbgUnIyiLzIjrx4CAaf9Y9LG7TAu6wKPqfbH6ZAkJTFSfjLNovbKhpOQcmO5VZGGay6yvXrX1TFW6C6RLITy74erxfUAStdtpP4nraCYqQYqn5zD4/1OmgweJt5vzGXW2ch7lrROEQhXB9lK+bjEeWx8TFW/+6ha/oRLnl6a2RBRL6mhwy3PoByNTKndB2MP4TygCJ/Ini4ivk74iSqVnoeuNJR/xUcU+kaIpZEIjxpAS2VECJU9fZvS5Gt84e5wl/t7bUKu+dlh/cUgHfk6+6bwzqGQYOe5A==' }
    };
    const localiv = 'LO2c/xLVb32/2VZTHlsSzw==';
    const ciphertext = Buffer.from('5+HKE91MbYyTbkP9vktH749GQ+j4y6tj3ArEl3Z9YRmMl5T2oGpvvAA5rLQZRfroyNuKbvjw/6qnYU7LgbgHDA==', 'base64');

    it('should successfully decrypt data encrypted through ursa', () =>
      getLocalDecipherer(keys, 'topsecret').then((decipherer) => {
        const decipher = decipherer(localiv);
        const unencrypted = decipher.update(ciphertext, null, 'utf8') + decipher.final('utf8');

        unencrypted.should.equal('a way a lone a last a loved a long the riverrun,');
      }));
  });
});

